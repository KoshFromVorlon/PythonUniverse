import time
import os


def apply_rule_30(left, center, right):
    """
    Математика Правила 30.
    Оно задает поведение клетки на основе ее текущего состояния и двух соседей.
    В бинарном виде это выглядит так (1 - черная, 0 - пустая):
    111 -> 0
    110 -> 0
    101 -> 0
    100 -> 1
    011 -> 1
    010 -> 1
    001 -> 1
    000 -> 0
    """
    # Собираем трех соседей в одно число от 0 до 7
    state = (left << 2) | (center << 1) | right

    # Элегантный битовый сдвиг для получения ответа из числа 30 (00011110)
    return (30 >> state) & 1


def run_universe(width=100, steps=60, delay=0.05):
    # 1. Начало времен: Создаем абсолютно пустое пространство (нули)
    row = [0] * width

    # 2. Большой взрыв: Зажигаем одну-единственную "квантовую искру" строго по центру
    row[width // 2] = 1

    print("Запуск алгоритма Вселенной...")
    time.sleep(1)

    # 3. Запускаем ход времени (кадры)
    for step in range(steps):
        # Отрисовываем текущий кадр: █ для материи (1), пробел для пустоты (0)
        visual_row = "".join(['█' if cell else ' ' for cell in row])
        print(visual_row)

        # Приостанавливаем процессор, чтобы человек успел увидеть такт времени
        time.sleep(delay)

        # Вычисляем следующий такт времени
        next_row = [0] * width

        for i in range(width):
            # Замыкаем края (чтобы Вселенная была закольцована как тор)
            left = row[i - 1]
            center = row[i]
            right = row[(i + 1) % width]

            # Каждая клетка вычисляется автономно по локальному правилу
            next_row[i] = apply_rule_30(left, center, right)

        # Перезаписываем состояние Вселенной
        row = next_row


if __name__ == "__main__":
    # Можно менять ширину терминала (width), количество кадров (steps) и скорость (delay)
    # Для лучшего эффекта сделайте окно терминала шире!
    run_universe(width=110, steps=60, delay=0.08)
